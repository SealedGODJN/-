# Java复习笔记



## 1 switch语句

知识点：

1、switch语句最好包含default部分。如果没有default部分，当没有一个case能匹配传入的值（switch表达式中的值）时，switch语句无法处理该值（相当于这一块程序没用，没有输出）。

2、例外：如果switch处理的值是enum类型的，且包含该类型的所有可能值的显示案例，则switch语句可以不包含default部分。



## 2 



## 5 明确的进行数据类型转换，不要依赖隐式类型转换

### 知识点：【待补充】



​															java数据精度表

| 四类   | 八种    | 字节数 | 数据表示范围                         |
| ------ | ------- | ------ | ------------------------------------ |
| 整型   | byte    | 1      | -128~127                             |
|        | short   | 2      | -32768~32767（2^15^-1）              |
|        | int     | 4      | -2^31^~2^31^-1                       |
|        | long    | 8      | -2^63^==L==~2^63^-1==L==             |
| 浮点型 | float   | 4      | -3.403==E==38==F==~3.403==E==38==F== |
|        | double  | 8      | -1.798==E==308~1.798==E==308         |
| 字符型 | char    | 2      | 表示一个字符，如（'a','A','0','家'） |
| 布尔型 | boolean | 1      | 只有两个值true、false                |





### 为什么要明确数据类型的精度呢？

个人想法：

1、在平时编码时，很少的题目会要求我们注意精度。而在生产环境下，会经常遇到非常大的数字。

2、解决方法：使用bigdecimal



### 注意：

1、当我们这样定义long a = 3；而不是long a = 3L，则默认表示为int型。这就是为什么long x = 9223372036854775807 （2^63-1）会报错，因为它已经超过int的大小范围了.

2、与1相反的是，当我们在定义float a = 3.0；而不是float a = 3.0F时，则默认表示为double型。别问我为什么Java这样定义数据，我也不懂它的任性- -|||



### 举例：

```java
long a = 1089212346l;
float b = 1.0f;
b = a;
System.out.println(b);
// 1.08921229E9

long a = 1089212234l;
float b = 1.0f;
b = a;
System.out.println(b);
// 1.08921229E9
// 结果相同，说明float只取前7位有效数字
```

将整型的数字转为浮点型，float取整型数字的==前7位有效数字==（当long型+float型运算时，会在得到的结果上取7位有效数字（包括小数点后的数值）存放在4个字节中，转成float型。这7位有效数字是==从高往低取==的，余下部分则自动被舍去了。）

